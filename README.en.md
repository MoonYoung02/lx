# lx

> Interface by Human, Logic by AI.

`lx` introduces a new programming paradigm where the developer controls the code structure while the LLM handles the implementation details via function encapsulation.

## Table of Contents
- [Features](#features)
- [How to Use](#how-to-use)
- [Installation](#installation)
- [License](#license)

## Features
- **Interface-Centric Design (LLM Encapsulation):** Developers design the program structure and data flow. `lx` treats the function name, parameters, and return types defined by the developer as an immutable contract. The AI cannot violate any terms of this contract and is restricted to implementing only the internal logic.

- **Continuity of Interface-Driven Development:** Once the input and output of a function are defined, the logic is considered complete. Programmers can maintain their development flow by immediately writing logic without getting bogged down in detailed implementation.

- **Developer Control:** Programmers can verify and modify the code generated by the LLM, maintaining full control over the LLM within existing programming syntax.

- **Token Optimization & Enhanced Security:** Only the function signature and prompt are sent to the LLM, not the entire file. This reduces costs and strengthens security.

- **Function-Level Isolation & Safety:** The LLM operates only within defined `lx` functions. It does not pollute the global structure of the project.

- **Hierarchical Configuration:** `lx` prioritizes configuration in the current directory; if absent, it falls back to the global configuration in the home directory. This enables "project-specific optimization," allowing different LLM models or API keys based on the project's nature.

- **Transparent Dependency Reporting:** If the AI uses external libraries, it reports them within the code using `// lx-dep` comments. The tool does not arbitrarily install packages; the developer reviews the code to decide on application and installation.

## How to Use

### Definition
- **lx Function:** A function where logic is implemented via `lx`.
- **lx Marker:** An implementation specification within an `lx` function that conveys the logic content to be implemented to the LLM.
- **lx Tool:** The tool that materializes the abstract contract specified in the `lx` function into actual logic.
- **lx Configuration:** Environmental specifications defining the LLM Provider, Model, and API Key used by the `lx` tool during logic generation.
- **lx Dependency:** System tools required by the `lx` tool to generate logic.

### lx Dependency
`lx` internally invokes external formatting tools to ensure the grammatical integrity and quality of the generated code.
Adhering to the Single Responsibility Principle, `lx` is not a package manager and does not pollute the system environment; therefore, the tools below are not installed automatically with `lx`.
Users must manually install the following tools:

- **Go:** goimports
- **Python:** ruff
- **JavaScript:** prettier

### lx Configuration
Before using `lx`, you must specify the LLM API Key and the model name.
Create an `lx-config.yaml` file and place it in one of the following two paths.
If files exist in both paths, the local configuration file takes precedence.

- **Global Path:** Placing the file in the user's home directory (`~/lx-config.yaml`) allows all projects to use the same common LLM settings.
- **Local Path:** Placing the file in the project's root directory (`./lx-config.yaml`) allows specific projects to use different models or API keys.

The `lx-config.yaml` file must be written in the following format:
```yaml
# lx-config.yaml
provider: "gemini"
api_key: "foo"
model: "bar"

```

The LLM providers currently supported by `lx` are:

- gemini

### lx Marker

Two styles of `lx` markers are available.

#### Comment lx Marker

Suitable when you want to use `lx` without extra library dependencies.
The code `lx("prompt content")` must be included inside a comment.
Simply writing a standard comment will not be recognized.

```go
// lx("Convert to Korean date format") (O)

// Change this function to Korean style (X)

```

#### Function lx Marker

Used when you want to leverage the editor's autocomplete and static analysis features.
Must be written according to the provided language-specific library (e.g., lxgo).

```go
lx.Generate("Convert to Korean date format") // Go
```

Programming languages supporting function markers:

* **Golang:** https://github.com/chebread/lxgo

### lx Function

`lx` functions follow these strict rules:

* **Naming Convention:** It is recommended to start function names with `LX_` or `lx_` to explicitly indicate they are generated by `lx`.
* **Explicit Interface:** Input/output data are not arguments of `lx.Generate`. They must be clearly defined by the function's argument types and return types.
* **Destructive Processing:** User-defined logic written inside an `lx` function is completely ignored and not reflected. Only the prompt content of `lx.Generate()` is sent to the LLM.
* **Syntactic Requirements:** Only minimal programming language syntax elements should be written inside an `lx` function to prevent compiler and IDE errors.

```go
package test

import (
	"fmt"

	"https://github.com/chebread/lxgo"
)

func main() {
	var year string = "2025-01-02"
	foo := LX_GetYear(year)

	var age = 30
	bar := LX_GetAge(age)

	fmt.Println(foo, bar)
}

func LX_GetYear(year string) (result string) {
	lx.Generate("Convert yyyy-dd-mm format to Korean date format")
	return
}

func LX_GetAge(year int) (result string) {
	// lx("Convert Korean age to international age")
	return
}
```

### lx Function Control

Since all developer logic inside an `lx` function is ignored, if you need to control data or perform additional processing before or after logic execution, you must wrap the `lx` function with another function. This embodies the "Development under developer control" approach that `lx` pursues.

```go
package test

import (
	"fmt"

	"https://github.com/chebread/lxgo"
)

func main() {
	var year string = "2025-01-02"
	res := ParseYear(year)

	fmt.Println(res)
}

func ParseYear(year string) string {
	koreanYear := LX_GetYear(year)
	foo := fmt.Sprintf("It is %v today!", koreanYear)
	return foo
}

func LX_GetYear(year string) (result string) {
	lx.Generate("Convert yyyy-dd-mm format to Korean date format")
	return
}
```

### lx Tool

Written `lx` functions and markers are empty shells that perform no function until the `lx` tool is executed.
Only by running the `lx` command is the abstract design converted into concrete code and injected into the function body.

For Mac users, the `lx` tool can be easily installed via Homebrew:

```bash
brew tap chebread/lx
brew install lx
```

For other operating systems, install via the following method:

1. Visit the [GitHub Releases](https://github.com/chebread/lx/releases) page.
2. Download the file matching your OS and architecture.
3. Unzip and add the `lx` executable to your system PATH environment variable.

### Code Injection and Materialization

When the `lx` tool is executed, it scans for `lx` functions and markers within the project, sends them to the LLM, and overwrites the existing marker code with the returned actual logic.
Note that this process modifies the actual source code, as `lx` functions are transformed into compilable, real code.

### Smart Generation

`lx` remembers functions that have already been converted into code.
Even if `lx` is executed repeatedly on functions where real code has already been generated by the tool, `lx` will never call the LLM again.
Feel free to run the `lx` command at any time without worry.

### Execution Before Compilation

The `lx` tool performs the single responsibility of LLM code generation only.
Building and running the program is entirely the developer's responsibility.
It is recommended to configure the pipeline so that `lx` runs immediately before Compile or Run.

### Safe Dependency Management

Even if the generated logic uses external libraries, `lx` does not arbitrarily install external packages.
Instead, it reports to the developer in two ways:

* **Code:** `// lx-dep: ...` comment specified at the top of the generated code.
* **Output:** A list of required installations reported to the terminal standard output.

The developer reviews this report and manually installs the libraries (e.g., `go get`) to control dependencies.
This stems from the `lx` design philosophy that the developer must have complete control over all project dependencies.

## License

**AGPL-3.0 LICENSE** &copy; 2026 Cha Haneum

This project follows the **AGPL-3.0** license.
Please ensure you check the license terms before use and distribution.
