# lx

[[한국어](README.kr.md)]

`lx` is an **LLM Functionization** tool that enables you to treat Large Language Models as standard programming functions.
The core philosophy of `lx` is to harness the power of LLMs while keeping both the model and its output strictly under the **developer's deterministic control**.



## Table of Contents
- [Features](#features)
- [Configuration](#configuration)
- [How to Use](#how-to-use)
- [Installation](#installation)
- [Supported Languages](#supported-languages)
- [Supported LLMs](#supported-LLMs)
- [License](#license)

## Features

* **Functionization of LLMs**: Converts natural language prompts into executable code and injects it directly into function bodies.
* **Explicit Developer Control**: Developers can inspect, verify, and refactor AI-generated code. AI is managed within the boundaries of existing programming syntax.
* **Development Continuity (Zero-Wait Workflow)**: Once the function's signature (input/output) is defined, the implementation is essentially complete. You don't have to wait for the AI to respond; simply continue writing the next business logic. Logic injection can be performed in bulk later via the `lx` command.
* **Function-Scoped Isolation**: The LLM operates exclusively within the function boundaries you permit. There is zero risk of the AI polluting the global scope or altering other parts of the source code.
* **Build-Time Generation**: Unlike RAG or runtime LLM calls, `lx` generates code during the development phase. This ensures maximum execution speed and production stability.

## Configuration

To use `lx`, an `lx-config.yaml` file is required in your project root. Currently, Google Gemini is the supported provider.

```yaml
provider: "gemini"
api_key: "YOUR_GEMINI_API_KEY"
model: "gemini-..."
```

## How to Use

### 1. Install the Library

To use the `lx.Generate` marker in Go, add the dependency to your project. (Currently, only Go is supported).

```bash
go get github.com/chebread/lxgo

```

### 2. Write Your Functions

`lx` is a **Function Body Injection** tool. It operates based on the following principles:

#### I. The "No Function, No Action" Principle

`lx` analyzes the Go **Abstract Syntax Tree (AST)** to find `FuncDecl` (function declarations) containing the `lx.Generate` marker. Prompts placed outside of a function scope are safely ignored. This prevents the AI from breaking the project's global structure.

#### II. Overwriting Behavior and Caveats

Executing `lx` will **delete all existing code** within the target function and replace it with the AI-generated logic.

* **Before Execution**: Any temporary code you write inside the function will be lost.
* **After Execution**: Once the AI code is injected, it becomes part of your source code, allowing for direct manual modification and debugging.

#### III. Maintaining Control via Wrapping

If you need to maintain custom logic before or after the AI-generated block, use the **Wrapping Pattern**:

```go
// The AI-managed core logic (Body will be overwritten by lx)
func lx_CoreLogic(input string) string {
    lx.Generate("Convert yyyy-dd-mm format to a Korean date string")
    return ""
}

// The Developer-managed wrapper (This remains untouched by lx)
func ProcessDate(date string) string {
    // Pre-processing logic
    if date == "" { return "Invalid Date" }
    
    return lx_CoreLogic(date)
}

```

#### IV. Function Requirements

* **Naming Convention (Recommended)**: It is highly recommended to prefix your functions with `lx_` or `LX_`. This serves as a clear signal to other developers that the function body is managed by an LLM.
* **Explicit Returns**: If the function has a return type, you must include a placeholder `return` statement to satisfy the language's syntax before running `lx`.

```go
package test

import "github.com/chebread/lxgo"

func LX_Year(year string) (result string) {
    // lx.Generate acts as a marker for code injection.
    lx.Generate("Convert yyyy-dd-mm format to Korean date style")
    
    // A return statement is required for valid Go syntax.
    return
}

```

### 3. Run the lx CLI

You must run the `lx` command before executing `go run .`. Without running `lx`, the functions will remain empty and perform no action.

```bash
# Analyzes all .go files in the current directory and injects AI logic
> lx .

```

Upon execution, the `lx.Generate` call and any placeholder code will be replaced with the **actual logic generated by the AI**. From this point forward, you have full ownership and control over the generated code.


## Installation

### On macOS

Install via Homebrew:

```bash
brew tap chebread/lx
brew install lx

```

### For other OS

1. Visit the [GitHub Releases](https://github.com/chebread/lx/releases) page.
2. Download the binary appropriate for your OS and architecture.
3. Extract the archive and add the `lx` executable to your system's `PATH`.


## Supported Languages

* **Golang**
* *More languages coming soon...*

## Supported LLMs

* **Google Gemini**
* *More LLMs coming soon...*


## License

**AGPL-3.0 LICENSE** &copy; 2026 Cha Haneum

This project is licensed under the **AGPL-3.0**. Please review the license terms before use or distribution.
